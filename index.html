<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tap a Block to Turn It White</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body {
      height: 100%;
      background: #191919;
      margin: 0;
      color: #eaeaea;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      overflow: hidden;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    header {
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid #2a2a2a;
    }
    .status { opacity: 0.8; font-size: 0.9rem; }
    #container {
      position: absolute; inset: 0;
      display: flex;
      flex-direction: column;
    }
    #game-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      gap: 20px;
      overflow: hidden;
    }
    #stage-wrap {
      position: relative;
      max-width: 600px;
      max-height: 450px;
      width: 100%;
      aspect-ratio: 4/3;
      border: 2px solid #2a2a2a;
      border-radius: 8px;
      overflow: hidden;
      background: #0a0a0a;
    }
    canvas {
      display: block;
      width: 100%; height: 100%;
      image-rendering: pixelated;
      cursor: pointer;
      touch-action: none;
    }
    #controls {
      display: flex;
      gap: 30px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    .arrow-pad {
      display: grid;
      grid-template-areas:
        ". up ."
        "left down right";
      gap: 4px;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(2, 60px);
    }
    .control-btn {
      background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
      border: 2px solid #4a4a4a;
      border-radius: 8px;
      color: #eaeaea;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.15s ease;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 500;
      touch-action: none;
    }
    .control-btn:hover {
      background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
      border-color: #5a5a5a;
      transform: translateY(-2px);
    }
    .control-btn:active {
      background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
      border-color: #3a3a3a;
      transform: translateY(0);
    }
    .arrow-btn {
      width: 60px;
      height: 60px;
    }
    #btn-up { grid-area: up; }
    #btn-left { grid-area: left; }
    #btn-down { grid-area: down; }
    #btn-right { grid-area: right; }
    .action-btn {
      width: 100px;
      height: 60px;
      font-size: 1rem;
    }
    a { color: #8ac6ff; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .level-picker { position: relative; }
    .level-button {
      display: inline-flex; align-items: center; gap: 8px;
      background: #232323; border: 1px solid #3a3a3a; color: #eaeaea;
      padding: 6px 12px; border-radius: 999px; cursor: pointer; font-weight: 600;
    }
    .level-button:hover { background: #2b2b2b; }
    .level-menu {
      position: absolute; top: 100%; left: 0; margin-top: 8px; min-width: 160px;
      background: #1a1a1a; border: 1px solid #2f2f2f; border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35); list-style: none; padding: 6px; display: none; z-index: 10;
    }
    .level-menu.open { display: block; }
    .level-menu li {
      padding: 8px 10px; border-radius: 8px; cursor: pointer;
    }
    .level-menu li:hover { background: #2a2a2a; }
    .level-menu li[aria-selected="true"] {
      background: #2f2f2f; outline: 1px solid #3f3f3f;
    }
  </style>
  <!-- Pyodide loads Python in the browser. The CDN version here is broadly compatible. -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>
<body>
  <div id="container">
    <header>
      <div class="level-picker">
        <button id="level-button" class="level-button" aria-haspopup="listbox" aria-expanded="false">
          <span id="level-current">snake</span>
          <svg width="14" height="14" viewBox="0 0 20 20" aria-hidden="true"><path d="M5 7l5 6 5-6z" fill="currentColor"/></svg>
        </button>
        <ul id="level-menu" class="level-menu" role="listbox" aria-activedescendant="">
          <!-- Filled by JS from LEVELS -->
        </ul>
      </div>
      <span class="status" id="status">loading Python‚Ä¶</span>
    </header>
    <div id="game-area">
      <div id="stage-wrap">
        <canvas id="stage"></canvas>
      </div>
      <div id="controls">
        <div class="arrow-pad">
          <button class="control-btn arrow-btn" id="btn-up">‚Üë</button>
          <button class="control-btn arrow-btn" id="btn-left">‚Üê</button>
          <button class="control-btn arrow-btn" id="btn-down">‚Üì</button>
          <button class="control-btn arrow-btn" id="btn-right">‚Üí</button>
        </div>
        <button class="control-btn action-btn" id="btn-space">Space</button>
        <button class="control-btn action-btn" id="btn-undo">Undo</button>
        <button class="control-btn action-btn" id="btn-reset">Reset</button>
      </div>
    </div>
  </div>

  <script type="module">
    // --------------------------
    // Python bridge via Pyodide
    // --------------------------
    let pyodide, boardReady = false;
    const LEVELS = ["snake", "as66", "shadow", "colortheory", "chase"];
    let currentLevel = "snake";

    const time = (label) => ({
  start: () => console.time(label),
  end: () => console.timeEnd(label),
});

async function loadPython() {
  const tLoad = time("loadPyodide");
  const tWrite = time("writeFiles");
  const tPy = time("runPython");

  try {
    tLoad.start();
    // 2) loadPyodide with stdout/stderr wired to devtools
    pyodide = await loadPyodide({ stdout: console.log, stderr: console.error });
    tLoad.end();
  } catch (err) {
    console.error("üîª Failed during loadPyodide()", err);
    throw err;
  }

  // Strict fetch that throws on non-OK and logs URL + status
  const fetchText = async (url) => {
    const res = await fetch(url + `?v=${Date.now()}`, { cache: "no-store" });
    if (!res.ok) {
      throw new Error(`Fetch failed ${res.status} ${res.statusText} for ${url}`);
    }
    const text = await res.text();
    if (!text.length) {
      throw new Error(`Empty response body for ${url}`);
    }
    return text;
  };

  const files = ["grid", "level", "bitpacking", "state", "helper", "game_template", "useful_objects"];
  const subfiles = [
    "actions",
    "begin","colors","events","get","lose","objects","press_button","press_tile",
    "reset","set","spotlight","undo","update","win"
  ];
  const game_template_files = [
    "as66", "snake", "shadow", "colortheory", "chase"
  ];

  try {
    tWrite.start();

    // 3) ensure subdir exists BEFORE any nested writes
    pyodide.FS.mkdirTree("grid_methods");
    pyodide.FS.mkdirTree("levels");
    // pyodide.FS.writeFile("/grid_methods/__init__.py", ""); // empty is fine
    // console.log("analyze /grid_methods:", pyodide.FS.analyzePath("/grid_methods"));


    // Write top-level files with verification
    for (const f of files) {
      const src = await fetchText(`./${f}.py`);
      pyodide.FS.writeFile(`${f}.py`, src);
    }

    // Write nested files with verification
    for (const sf of subfiles) {
      const src = await fetchText(`./grid_methods/${sf}.py`);
      pyodide.FS.writeFile(`${sf}.py`, src);
    }

    // Write nested files with verification
    for (const sf of game_template_files) {
      const src = await fetchText(`./levels/${sf}.py`);
      pyodide.FS.writeFile(`${sf}.py`, src);
      const src2 = await fetchText(`./levels/${sf}-design.json`);
      pyodide.FS.writeFile(`${sf}-design.json`, src2);
    }

    // Optional: list directories to confirm layout
    console.log("Root dir:", pyodide.FS.readdir("/"));
    console.log("/grid_methods:", pyodide.FS.readdir("/grid_methods"));
    tWrite.end();
  } catch (err) {
    console.error("üîª Failed while writing/validating files in Pyodide FS:", err);
    // Extra hints for common FS errors
    if (String(err).includes("ENOENT")) {
      console.error("Tip: path not found (missing directory or wrong relative URL). Check that grid_methods exists before writes and the fetch paths are correct.");
    }
    throw err;
  }

  // 4) run Python with clear tracebacks and context
  try {
    tPy.start();
    await pyodide.runPythonAsync(`
import sys
print("sys.path:", sys.path)

from grid import grid_stateful
from level import choose_game

board = None

def py_new_board(level_name: str):
    global board
    board = grid_stateful()
    chosen_game = choose_game(level_name, board)
    board.level = chosen_game
    board.input({"event": "init"})
    return True

def py_get_size():
    return tuple(board.actual_size) if board is not None else (0, 0)

def py_get_color_grid():
    return board.input("color_grid") if board is not None else []

def py_begin():
    if board is not None:
        board.input({"event": "begin"})

def py_press_tile(c, r):
    if board is not None:
        return board.input({"event": "press_tile", "position": [c, r]})

def py_press_button(name):
    if board is not None:
        return board.input({"event": "press_button", "button": name})

def py_update():
    if board is None:
        return [], False
    out = list(board.input("update"))
    anim = bool(getattr(board, "animations", None) or (getattr(board, "board", None) and getattr(board.board, "animations", False)))
    return out, anim
`);
    tPy.end();
  } catch (err) {
    console.error("üîª Python execution failed. Full traceback above from stderr.", err);
    // Often this means an import path issue. Show some extra diagnostics:
    try {
      const diag = await pyodide.runPythonAsync(`
import sys, pkgutil, os
{
  "cwd": os.getcwd(),
  "sys_path": sys.path,
  "have_grid": bool(pkgutil.find_loader("grid")),
  "have_level": bool(pkgutil.find_loader("level")),
  "have_helper": bool(pkgutil.find_loader("helper")),
  "have_grid_methods": bool(pkgutil.find_loader("grid_methods")),
}
`);
      console.error("Python import diagnostics:", diag.toJs ? diag.toJs() : diag);
    } catch {}
    throw err;
  }

  boardReady = true;
  document.getElementById("status").textContent = "ready";
}

    // --------------------------
    // Canvas + layout (JS)
    // --------------------------
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");
    const DPR = () => (window.devicePixelRatio || 1);

    // Configurable bits (mirrors your Python class fields)
    let N_COLS = 0, N_ROWS = 0;
    let MARGIN_PX = 0;
    let INITIAL_SIZE = [800, 600]; // replaced at runtime after reading board size + block size
    let CELL_SIZE = 0, X0 = 0, Y0 = 0;
    let colors = [];      // [row][col] -> [r,g,b]
    let rects = [];       // [row][col] -> {x,y,w,h}
    const BLOCK_BX = 50;  // same default as your __init__(block_bx=50)
    let tileOpacity = []; // [row][col] -> opacity (0-1) for fade-in animation
    let hoveredCell = null; // [row, col] of currently hovered cell
    let hoverEnabled = true; // whether hover effect is active
    let clickAnimations = []; // array of {x, y, progress, startTime} for click animations

    function setCanvasCSSSize(wCSS, hCSS) {
      const dpr = DPR();
      canvas.width = Math.max(1, Math.floor(wCSS * dpr));
      canvas.height = Math.max(1, Math.floor(hCSS * dpr));
      canvas.style.width = `${wCSS}px`;
      canvas.style.height = `${hCSS}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function layout(w, h) {
      const rows = N_ROWS, cols = N_COLS, margin = MARGIN_PX;

      const cell = Math.min(
        Math.floor((w - (cols + 1) * margin) / cols),
        Math.floor((h - (rows + 1) * margin) / rows)
      );
      CELL_SIZE = Math.max(1, cell);
      const gridW = cols * CELL_SIZE + (cols + 1) * margin;
      const gridH = rows * CELL_SIZE + (rows + 1) * margin;
      X0 = Math.floor((w - gridW) / 2);
      Y0 = Math.floor((h - gridH) / 2);
      return [X0, Y0, CELL_SIZE];
    }

    function buildRects() {
      const x0 = X0, y0 = Y0, cell = CELL_SIZE, margin = MARGIN_PX;
      const rows = N_ROWS, cols = N_COLS;
      const out = [];
      for (let r = 0; r < rows; r++) {
        const rowRects = [];
        for (let c = 0; c < cols; c++) {
          const x = x0 + margin + c * (cell + margin);
          const y = y0 + margin + (rows - 1 - r) * (cell + margin); // flipped like your code
          rowRects.push({ x, y, w: cell, h: cell });
        }
        out.push(rowRects);
      }
      return out;
    }

    function cellAt(mx, my) {
      const cols = N_COLS, rows = N_ROWS, margin = MARGIN_PX, cell = CELL_SIZE, x0 = X0, y0 = Y0;
      const relX = mx - x0, relY = my - y0;
      if (relX < 0 || relY < 0) return null;
      const stride = cell + margin;
      const c = Math.floor(relX / stride);
      const r = Math.floor(relY / stride);
      if (r >= 0 && r < rows && c >= 0 && c < cols) {
        // return (row, col) with flipped row index to match Python
        return [rows - 1 - r, c];
      }
      return null;
    }

    function rgbStr([r, g, b]) {
      return `rgb(${r|0},${g|0},${b|0})`;
    }

    function drawAll() {
      ctx.fillStyle = "rgb(25,25,25)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < N_ROWS; r++) {
        for (let c = 0; c < N_COLS; c++) {
          drawCell(r, c);
        }
      }
      // Draw hover border on top if there's a hovered cell and hover is enabled
      if (hoveredCell && hoverEnabled) {
        drawHoverBorder(hoveredCell[0], hoveredCell[1]);
      }
      // Draw click animations on top
      drawClickAnimations();
    }

    function drawCell(r, c) {
      const rect = rects[r][c];
      const opacity = tileOpacity[r] && tileOpacity[r][c] !== undefined ? tileOpacity[r][c] : 1;
      ctx.globalAlpha = opacity;
      ctx.fillStyle = rgbStr(colors[r][c]);
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      
      // Draw very faint border around each tile
      ctx.strokeStyle = "rgba(80, 80, 80, 0.15)";
      ctx.lineWidth = 0.5;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      
      ctx.globalAlpha = 1;
    }

    function drawHoverBorder(r, c) {
      const rect = rects[r][c];
      ctx.strokeStyle = "rgb(80, 160, 255)"; // Blue border
      ctx.lineWidth = 1;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    }

    function drawClickAnimations() {
      for (const anim of clickAnimations) {
        const maxRadius = CELL_SIZE * 3;
        const radius = anim.progress * maxRadius;
        const opacity = 1 - anim.progress;
        
        ctx.globalAlpha = opacity;
        ctx.strokeStyle = "rgb(80, 160, 255)";
        ctx.lineWidth = 7;
        ctx.beginPath();
        ctx.arc(anim.x, anim.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    // --------------------------------
    // Initialize board from Python side
    // --------------------------------
    async function bootstrap() {
      await loadPython();

      await setLevel(currentLevel); // initial level

      // Read board size from Python and set up grid
      // py_get_size returns (width, height) in tiles
      const [width, height] = pyodide.runPython("py_get_size()");
      N_COLS = width;
      N_ROWS = height;

      // INITIAL_SIZE mirrors your block size * tiles (like __init__)
      INITIAL_SIZE = [N_COLS * BLOCK_BX, N_ROWS * BLOCK_BX];

      // Set canvas CSS size initially to INITIAL_SIZE, then layout
      // setCanvasCSSSize(INITIAL_SIZE[0], INITIAL_SIZE[1]);
      // layout(INITIAL_SIZE[0], INITIAL_SIZE[1]);

      // Pull the color grid from Python
      // Ensure conversion to plain JS arrays
      const pyColors = pyodide.runPython("py_get_color_grid()");
      colors = pyColors.toJs({ create_proxies: false });

      // Initialize opacity array for fade-in animation
      tileOpacity = [];
      for (let r = 0; r < N_ROWS; r++) {
        tileOpacity[r] = [];
        for (let c = 0; c < N_COLS; c++) {
          tileOpacity[r][c] = 0;
        }
      }

      rects = buildRects();
      drawAll();

      // Let the DOM finish layout, then size to the container
      await new Promise(requestAnimationFrame);
      resizeToContainer();

      // Start fade-in animation
      animateTilesFadeIn();

      // Tell Python level logic to begin (like your main())
      pyodide.runPython("py_begin()");

      // Start both loops
      gameLogicLoop();  // Game logic at 50ms intervals
      animationLoop();  // Smooth animations at 60fps
    }

    async function setLevel(level) {
      console.log("Setting level to", level);
      currentLevel = level;
      // 1) Re-create the Python board for this level
      await pyodide.runPythonAsync(`py_new_board("${level}")`);
      
      // 2) Pull size and colors anew
      const [width, height] = pyodide.runPython("py_get_size()");
      N_COLS = width; N_ROWS = height;
      INITIAL_SIZE = [N_COLS * BLOCK_BX, N_ROWS * BLOCK_BX];

      const pyColors = pyodide.runPython("py_get_color_grid()");
      colors = pyColors.toJs({ create_proxies: false });

      // 3) Rebuild layout + rects + fresh fade-in
      rects = buildRects();
      // Reset opacity so new grid fades in
      tileOpacity = Array.from({ length: N_ROWS }, () => Array(N_COLS).fill(0));
      drawAll();
      resizeToContainer();
      animateTilesFadeIn();

      // 4) Begin level logic
      pyodide.runPython("py_begin()");

      // 5) Update UI text
      document.getElementById("level-current").textContent = level;
    }

    // Fade in tiles with a diagonal wave pattern
    function animateTilesFadeIn() {
      const totalTiles = N_ROWS * N_COLS;
      const maxDelay = 800; // Total animation duration in ms
      const fadeDuration = 400; // Individual tile fade duration in ms
      
      // Create animation for each tile with staggered timing
      for (let r = 0; r < N_ROWS; r++) {
        for (let c = 0; c < N_COLS; c++) {
          // Diagonal wave: tiles further from top-left start later
          const diagonalIndex = r + c;
          const maxDiagonal = (N_ROWS - 1) + (N_COLS - 1);
          const delay = (diagonalIndex / maxDiagonal) * maxDelay;
          
          animateTile(r, c, delay, fadeDuration);
        }
      }
    }

    function animateTile(r, c, delay, duration) {
      setTimeout(() => {
        const startTime = Date.now();
        function updateOpacity() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          // Ease-out cubic for smooth animation
          tileOpacity[r][c] = 1 - Math.pow(1 - progress, 3);
          
          drawCell(r, c);
          if (hoveredCell && hoveredCell[0] === r && hoveredCell[1] === c) {
            drawHoverBorder(r, c);
          }
          
          if (progress < 1) {
            requestAnimationFrame(updateOpacity);
          }
        }
        updateOpacity();
      }, delay);
    }

    function startClickAnimation(x, y) {
      clickAnimations.push({
        x: x,
        y: y,
        progress: 0,
        startTime: Date.now()
      });
    }

    function updateClickAnimations() {
      const duration = 400; // Animation duration in ms
      const now = Date.now();
      
      // Update all animations
      for (let i = clickAnimations.length - 1; i >= 0; i--) {
        const anim = clickAnimations[i];
        const elapsed = now - anim.startTime;
        anim.progress = Math.min(elapsed / duration, 1);
        
        // Remove completed animations
        if (anim.progress >= 1) {
          clickAnimations.splice(i, 1);
        }
      }
    }

    // --------------------------
    // Event handling
    // --------------------------
    function resizeToContainer() {
      const wrap = document.getElementById("stage-wrap");
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      setCanvasCSSSize(w, h);
      layout(w, h);
      rects = buildRects();
      drawAll();
    }

    // Resize canvas when window changes
    new ResizeObserver(() => resizeToContainer()).observe(document.getElementById("stage-wrap"));

    canvas.addEventListener("mousedown", (ev) => {
      if (!boardReady) return;
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const hit = cellAt(x, y);
      if (!hit) return;
      const [r, c] = hit;
      
      // Start click animation at the center of the clicked cell
      const cellRect = rects[r][c];
      const centerX = cellRect.x + cellRect.w / 2;
      const centerY = cellRect.y + cellRect.h / 2;
      startClickAnimation(centerX, centerY);
      
      // Disable hover and clear the hovered cell
      hoverEnabled = false;
      hoveredCell = null;
      
      // Send to Python: position = [c, r]
      pyodide.runPython(`py_press_tile(${c}, ${r})`);
    });

    canvas.addEventListener("mousemove", (ev) => {
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const hit = cellAt(x, y);
      
      // Re-enable hover on mouse move
      if (!hoverEnabled) {
        hoverEnabled = true;
      }
      
      // Check if hover changed
      const changed = (hoveredCell === null && hit !== null) ||
                      (hoveredCell !== null && hit === null) ||
                      (hoveredCell && hit && (hoveredCell[0] !== hit[0] || hoveredCell[1] !== hit[1]));
      
      if (changed) {
        hoveredCell = hit;
        drawAll();
      }
    });

    canvas.addEventListener("mouseleave", () => {
      if (hoveredCell !== null) {
        hoveredCell = null;
        drawAll();
      }
    });

    // Prevent context menu on long press (mobile)
    canvas.addEventListener("contextmenu", (ev) => {
      ev.preventDefault();
    });

    // Prevent double-tap zoom on mobile
    let lastTouchEnd = 0;
    canvas.addEventListener("touchend", (ev) => {
      const now = (new Date()).getTime();
      if (now - lastTouchEnd <= 300) {
        ev.preventDefault();
      }
      lastTouchEnd = now;
    });

    // Handle touch events for mobile interaction
    canvas.addEventListener("touchstart", (ev) => {
      if (ev.touches.length > 1) {
        // Prevent zoom gestures
        ev.preventDefault();
      } else if (ev.touches.length === 1) {
        // Handle single touch for game interaction
        ev.preventDefault();
        const touch = ev.touches[0];
        const rect = canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const hit = cellAt(x, y);
        if (!hit) return;
        const [r, c] = hit;
        
        // Start click animation at the center of the clicked cell
        const cellRect = rects[r][c];
        const centerX = cellRect.x + cellRect.w / 2;
        const centerY = cellRect.y + cellRect.h / 2;
        startClickAnimation(centerX, centerY);
        
        // Disable hover and clear the hovered cell
        hoverEnabled = false;
        hoveredCell = null;
        
        // Send to Python: position = [c, r]
        pyodide.runPython(`py_press_tile(${c}, ${r})`);
      }
    });

    canvas.addEventListener("touchmove", (ev) => {
      if (ev.touches.length > 1) {
        ev.preventDefault();
      }
    });

    const keyMap = {
      " ": "space",
      "a": "left", "A": "left",
      "w": "up",   "W": "up",
      "s": "down", "S": "down",
      "d": "right","D": "right",
      "ArrowUp": "up",
      "ArrowDown": "down",
      "ArrowLeft": "left",
      "ArrowRight": "right",
      "Enter": "undo",
      "0": "reset"
    };

    window.addEventListener("keydown", (ev) => {
      const button = keyMap[ev.key];
      if (!button || !boardReady) return;
      ev.preventDefault();
      pyodide.runPython(`py_press_button("${button}")`);
    });

    // Control button event listeners
    const controlButtons = {
      "btn-up": "up",
      "btn-down": "down",
      "btn-left": "left",
      "btn-right": "right",
      "btn-space": "space",
      "btn-undo": "undo",
      "btn-reset": "reset"
    };

    Object.entries(controlButtons).forEach(([id, action]) => {
      const button = document.getElementById(id);
      
      // Handle click events
      button.addEventListener("click", () => {
        if (!boardReady) return;
        pyodide.runPython(`py_press_button("${action}")`);
      });
      
      // Handle touch events for mobile
      button.addEventListener("touchstart", (ev) => {
        ev.preventDefault();
        if (!boardReady) return;
        pyodide.runPython(`py_press_button("${action}")`);
      });
    });

    // ----- Level dropdown wiring -----
    const levelBtn = document.getElementById("level-button");
    const levelMenu = document.getElementById("level-menu");
    const levelCurrent = document.getElementById("level-current");

    // Build menu items from LEVELS
    function buildLevelMenu() {
      levelMenu.innerHTML = "";
      for (const name of LEVELS) {
        const li = document.createElement("li");
        li.textContent = name;
        li.id = `level-${name}`;
        li.setAttribute("role", "option");
        li.setAttribute("aria-selected", name === currentLevel ? "true" : "false");
        li.addEventListener("click", async () => {
          if (!boardReady) return;
          // Close menu
          levelMenu.classList.remove("open");
          levelBtn.setAttribute("aria-expanded", "false");

          // Only act if changed
          if (name !== currentLevel) {
            // Show transient status
            document.getElementById("status").textContent = `loading ${name}‚Ä¶`;
            await setLevel(name);
            document.getElementById("status").textContent = "ready";
            // update selected visuals
            levelMenu.querySelectorAll("li[aria-selected]").forEach(n => n.setAttribute("aria-selected", "false"));
            li.setAttribute("aria-selected", "true");
          }
        });
        levelMenu.appendChild(li);
      }
    }
    buildLevelMenu();

    levelBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const open = levelMenu.classList.toggle("open");
      levelBtn.setAttribute("aria-expanded", String(open));
    });

    document.addEventListener("click", (e) => {
      if (!levelMenu.contains(e.target) && e.target !== levelBtn) {
        levelMenu.classList.remove("open");
        levelBtn.setAttribute("aria-expanded", "false");
      }
    });

    // --------------------------
    // Game loop (poll updates from Python at 50ms intervals)
    // --------------------------
    async function gameLogicLoop() {
      if (boardReady) {
        // Get a PyProxy result
        const pyRes = pyodide.runPython("py_update()");
        // Convert to plain JS (tuple -> array, dict -> plain object)
        const [updates, anim] = pyRes.toJs({
          create_proxies: false,
          dict_converter: Object.fromEntries
        });
        // Free the proxy
        pyRes.destroy();

        for (const u of updates) {
          if (u.result === "change_color") {
            const r = u.position[1];
            const c = u.position[0];
            colors[r][c] = u.to_color;
          }
        }
        // you can use `anim` if you want to conditionally throttle
      }
      await sleep(50);
      gameLogicLoop();
    }

    // --------------------------
    // Animation loop (runs at 60fps for smooth animations)
    // --------------------------
    function animationLoop() {
      // Update click animations
      updateClickAnimations();
      
      // Always redraw to keep animations smooth
      drawAll();
      
      requestAnimationFrame(animationLoop);
    }
    
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Kick everything off
    bootstrap();
  </script>
</body>
</html>