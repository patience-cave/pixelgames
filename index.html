<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tap a Block to Turn It White</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      background: #191919;
      margin: 0;
      color: #eaeaea;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }
    header {
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid #2a2a2a;
    }
    .status { opacity: 0.8; font-size: 0.9rem; }
    #container {
      position: absolute; inset: 0;
      display: grid; grid-template-rows: auto 1fr;
    }
    #stage-wrap {
      position: relative; overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%; height: 100%;
      image-rendering: pixelated;
      cursor: pointer;
    }
    .keys { margin-left: auto; display: flex; gap: 8px; }
    kbd { background: #2b2b2b; padding: 2px 6px; border-radius: 6px; border: 1px solid #3b3b3b; }
    a { color: #8ac6ff; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
  <!-- Pyodide loads Python in the browser. The CDN version here is broadly compatible. -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>
<body>
  <div id="container">
    <header>
      <strong>Tap a Block to Turn It White</strong>
      <span class="status" id="status">loading Python‚Ä¶</span>
      <div class="keys">
        <span class="status">keys:</span>
        <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>
        <kbd>‚Üë</kbd><kbd>‚Üì</kbd><kbd>‚Üê</kbd><kbd>‚Üí</kbd>
        <kbd>Space</kbd><kbd>Enter</kbd><kbd>0</kbd>
      </div>
    </header>
    <div id="stage-wrap">
      <canvas id="stage"></canvas>
    </div>
  </div>

  <script type="module">
    // --------------------------
    // Python bridge via Pyodide
    // --------------------------
    let pyodide, boardReady = false;

    const time = (label) => ({
  start: () => console.time(label),
  end: () => console.timeEnd(label),
});

async function loadPython() {
  const tLoad = time("loadPyodide");
  const tWrite = time("writeFiles");
  const tPy = time("runPython");

  try {
    tLoad.start();
    // 2) loadPyodide with stdout/stderr wired to devtools
    pyodide = await loadPyodide({ stdout: console.log, stderr: console.error });
    tLoad.end();
  } catch (err) {
    console.error("üîª Failed during loadPyodide()", err);
    throw err;
  }

  // Strict fetch that throws on non-OK and logs URL + status
  const fetchText = async (url) => {
    const res = await fetch(url + `?v=${Date.now()}`, { cache: "no-store" });
    if (!res.ok) {
      throw new Error(`Fetch failed ${res.status} ${res.statusText} for ${url}`);
    }
    const text = await res.text();
    if (!text.length) {
      throw new Error(`Empty response body for ${url}`);
    }
    return text;
  };

  const files = ["grid", "level", "bitpacking", "state"];
  const subfiles = [
    "actions","begin","colors","events","get","lose","press_button","press_tile",
    "reset","set","spotlight","undo","update","win"
  ];

  try {
    tWrite.start();

    // 3) ensure subdir exists BEFORE any nested writes
    pyodide.FS.mkdirTree("grid_methods");
    // pyodide.FS.writeFile("/grid_methods/__init__.py", ""); // empty is fine
    // console.log("analyze /grid_methods:", pyodide.FS.analyzePath("/grid_methods"));


    // Write top-level files with verification
    for (const f of files) {
      const src = await fetchText(`./${f}.py`);
      pyodide.FS.writeFile(`${f}.py`, src);
    }

    // Write nested files with verification
    for (const sf of subfiles) {
      const src = await fetchText(`./grid_methods/${sf}.py`);
      pyodide.FS.writeFile(`${sf}.py`, src);
    }

    // Optional: list directories to confirm layout
    console.log("Root dir:", pyodide.FS.readdir("/"));
    console.log("/grid_methods:", pyodide.FS.readdir("/grid_methods"));
    tWrite.end();
  } catch (err) {
    console.error("üîª Failed while writing/validating files in Pyodide FS:", err);
    // Extra hints for common FS errors
    if (String(err).includes("ENOENT")) {
      console.error("Tip: path not found (missing directory or wrong relative URL). Check that grid_methods exists before writes and the fetch paths are correct.");
    }
    throw err;
  }

  // 4) run Python with clear tracebacks and context
  try {
    tPy.start();
    await pyodide.runPythonAsync(`
import sys
print("sys.path:", sys.path)

from grid import grid_stateful
from level import press_button, press_tile, initialize, begin

board = grid_stateful()
board.begin_method = begin
board.press_button_method = press_button
board.press_tile_method = press_tile
board.initialize_method = initialize
board.input({"event": "init"})

def py_get_size():
    return tuple(board.actual_size)

def py_get_color_grid():
    return board.input("color_grid")

def py_begin():
    board.input({"event": "begin"})

def py_press_tile(c, r):
    return board.input({"event": "press_tile", "position": [c, r]})

def py_press_button(name):
    return board.input({"event": "press_button", "button": name})

def py_update():
    out = list(board.input("update"))
    anim = bool(getattr(board, "animations", None) or (getattr(board, "board", None) and getattr(board.board, "animations", False)))
    return out, anim
    `);
    tPy.end();
  } catch (err) {
    console.error("üîª Python execution failed. Full traceback above from stderr.", err);
    // Often this means an import path issue. Show some extra diagnostics:
    try {
      const diag = await pyodide.runPythonAsync(`
import sys, pkgutil, os
{
  "cwd": os.getcwd(),
  "sys_path": sys.path,
  "have_grid": bool(pkgutil.find_loader("grid")),
  "have_level": bool(pkgutil.find_loader("level")),
  "have_grid_methods": bool(pkgutil.find_loader("grid_methods")),
}
`);
      console.error("Python import diagnostics:", diag.toJs ? diag.toJs() : diag);
    } catch {}
    throw err;
  }

  boardReady = true;
  document.getElementById("status").textContent = "ready";
}

    // --------------------------
    // Canvas + layout (JS)
    // --------------------------
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");
    const DPR = () => (window.devicePixelRatio || 1);

    // Configurable bits (mirrors your Python class fields)
    let N_COLS = 0, N_ROWS = 0;
    let MARGIN_PX = 1;
    let INITIAL_SIZE = [800, 600]; // replaced at runtime after reading board size + block size
    let CELL_SIZE = 0, X0 = 0, Y0 = 0;
    let colors = [];      // [row][col] -> [r,g,b]
    let rects = [];       // [row][col] -> {x,y,w,h}
    const BLOCK_BX = 50;  // same default as your __init__(block_bx=50)

    function setCanvasCSSSize(wCSS, hCSS) {
      const dpr = DPR();
      canvas.width = Math.max(1, Math.floor(wCSS * dpr));
      canvas.height = Math.max(1, Math.floor(hCSS * dpr));
      canvas.style.width = `${wCSS}px`;
      canvas.style.height = `${hCSS}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function layout(w, h) {
      const rows = N_ROWS, cols = N_COLS, margin = MARGIN_PX;

      const cell = Math.min(
        Math.floor((w - (cols + 1) * margin) / cols),
        Math.floor((h - (rows + 1) * margin) / rows)
      );
      CELL_SIZE = Math.max(1, cell);
      const gridW = cols * CELL_SIZE + (cols + 1) * margin;
      const gridH = rows * CELL_SIZE + (rows + 1) * margin;
      X0 = Math.floor((w - gridW) / 2);
      Y0 = Math.floor((h - gridH) / 2);
      return [X0, Y0, CELL_SIZE];
    }

    function buildRects() {
      const x0 = X0, y0 = Y0, cell = CELL_SIZE, margin = MARGIN_PX;
      const rows = N_ROWS, cols = N_COLS;
      const out = [];
      for (let r = 0; r < rows; r++) {
        const rowRects = [];
        for (let c = 0; c < cols; c++) {
          const x = x0 + margin + c * (cell + margin);
          const y = y0 + margin + (rows - 1 - r) * (cell + margin); // flipped like your code
          rowRects.push({ x, y, w: cell, h: cell });
        }
        out.push(rowRects);
      }
      return out;
    }

    function cellAt(mx, my) {
      const cols = N_COLS, rows = N_ROWS, margin = MARGIN_PX, cell = CELL_SIZE, x0 = X0, y0 = Y0;
      const relX = mx - x0, relY = my - y0;
      if (relX < 0 || relY < 0) return null;
      const stride = cell + margin;
      const c = Math.floor(relX / stride);
      const r = Math.floor(relY / stride);
      if (r >= 0 && r < rows && c >= 0 && c < cols) {
        // return (row, col) with flipped row index to match Python
        return [rows - 1 - r, c];
      }
      return null;
    }

    function rgbStr([r, g, b]) {
      return `rgb(${r|0},${g|0},${b|0})`;
    }

    function drawAll() {
      ctx.fillStyle = "rgb(25,25,25)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < N_ROWS; r++) {
        for (let c = 0; c < N_COLS; c++) {
          const rect = rects[r][c];
          ctx.fillStyle = rgbStr(colors[r][c]);
          ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        }
      }
    }

    function drawCell(r, c) {
      const rect = rects[r][c];
      ctx.fillStyle = rgbStr(colors[r][c]);
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    }

    // --------------------------------
    // Initialize board from Python side
    // --------------------------------
    async function bootstrap() {
      await loadPython();

      // Read board size from Python and set up grid
      // py_get_size returns (width, height) in tiles
      const [width, height] = pyodide.runPython("py_get_size()");
      N_COLS = width;
      N_ROWS = height;

      // INITIAL_SIZE mirrors your block size * tiles (like __init__)
      INITIAL_SIZE = [N_COLS * BLOCK_BX, N_ROWS * BLOCK_BX];

      // Set canvas CSS size initially to INITIAL_SIZE, then layout
      // setCanvasCSSSize(INITIAL_SIZE[0], INITIAL_SIZE[1]);
      // layout(INITIAL_SIZE[0], INITIAL_SIZE[1]);

      // Pull the color grid from Python
      // Ensure conversion to plain JS arrays
      const pyColors = pyodide.runPython("py_get_color_grid()");
      colors = pyColors.toJs({ create_proxies: false });

      rects = buildRects();
      drawAll();

      // Let the DOM finish layout, then size to the container
      await new Promise(requestAnimationFrame);
      resizeToContainer();

      // Tell Python level logic to begin (like your main())
      pyodide.runPython("py_begin()");

      // Start loop
      requestAnimationFrame(tick);
    }

    // --------------------------
    // Event handling
    // --------------------------
    function resizeToContainer() {
      const wrap = document.getElementById("stage-wrap");
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      setCanvasCSSSize(w, h);
      layout(w, h);
      rects = buildRects();
      drawAll();
    }

    // Resize canvas when window changes
    new ResizeObserver(() => resizeToContainer()).observe(document.getElementById("stage-wrap"));

    canvas.addEventListener("mousedown", (ev) => {
      if (!boardReady) return;
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const hit = cellAt(x, y);
      if (!hit) return;
      const [r, c] = hit;
      // Send to Python: position = [c, r]
      pyodide.runPython(`py_press_tile(${c}, ${r})`);
    });

    const keyMap = {
      " ": "space",
      "a": "left", "A": "left",
      "w": "up",   "W": "up",
      "s": "down", "S": "down",
      "d": "right","D": "right",
      "ArrowUp": "up",
      "ArrowDown": "down",
      "ArrowLeft": "left",
      "ArrowRight": "right",
      "Enter": "undo",
      "0": "reset"
    };

    window.addEventListener("keydown", (ev) => {
      const button = keyMap[ev.key];
      if (!button || !boardReady) return;
      ev.preventDefault();
      pyodide.runPython(`py_press_button("${button}")`);
    });

    // --------------------------
    // Game loop (poll updates)
    // --------------------------
    function tick() {
      if (boardReady) {
        // Get a PyProxy result
        const pyRes = pyodide.runPython("py_update()");
        // Convert to plain JS (tuple -> array, dict -> plain object)
        const [updates, anim] = pyRes.toJs({
          create_proxies: false,
          dict_converter: Object.fromEntries
        });
        // Free the proxy
        pyRes.destroy();

        for (const u of updates) {
          if (u.result === "change_color") {
            const r = u.position[1];
            const c = u.position[0];
            colors[r][c] = u.to_color;
            drawCell(r, c);
          }
        }
        // you can use `anim` if you want to conditionally throttle
      }
      requestAnimationFrame(tick);
    }

    // Kick everything off
    bootstrap();
  </script>
</body>
</html>